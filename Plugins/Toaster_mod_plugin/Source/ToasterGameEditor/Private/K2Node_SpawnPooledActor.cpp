#include "K2Node_SpawnPooledActor.h"
#include "ToasterGameplayStatics.h"
#include "EdGraph/EdGraph.h"
#include "EdGraphSchema_K2.h"
#include "K2Node_CallFunction.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "KismetCompilerMisc.h"
#include "KismetCompiler.h"
#include "BlueprintNodeSpawner.h"
#include "EditorCategoryUtils.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "ActorPool.h"

#define LOCTEXT_NAMESPACE "K2Node_SpawnPooledActor"

struct FSpawnPooledActorHelper
{
    static const FName SpawnTransformPinName;
    static const FName OwnerPinName;
    static const FName RecyclePinName;
};

const FName FSpawnPooledActorHelper::SpawnTransformPinName(TEXT("SpawnTransform"));
const FName FSpawnPooledActorHelper::OwnerPinName(TEXT("Owner"));
const FName FSpawnPooledActorHelper::RecyclePinName(TEXT("ReclaimIfEmpty"));

UK2Node_SpawnPooledActor::UK2Node_SpawnPooledActor(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    NodeTooltip = LOCTEXT("NodeTooltip", "Attemps to unpool and actor from the actor pool");
}

void UK2Node_SpawnPooledActor::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

    // RemovePin( FindPin(UEdGraphSchema_K2::PN_ReturnValue, EGPD_Output) );

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Transform pin
	UScriptStruct* TransformStruct = TBaseStructure<FTransform>::Get();
	UEdGraphPin* TransformPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TransformStruct, FSpawnPooledActorHelper::SpawnTransformPinName);

    // Recycle pin
    UEdGraphPin* RecyclePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, FSpawnPooledActorHelper::RecyclePinName);
    K2Schema->SetPinAutogeneratedDefaultValue(RecyclePin, TEXT("true"));

    // Owner pin
	UEdGraphPin* OwnerPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, AActor::StaticClass(), FSpawnPooledActorHelper::OwnerPinName);
	OwnerPin->bAdvancedView = true;
	if (ENodeAdvancedPins::NoPins == AdvancedPinDisplay)
	{
		AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
	}
}

FText UK2Node_SpawnPooledActor::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    FText NodeTitle = NSLOCTEXT("K2Node", "SpawnActor_BaseTitle", "Spawn Pooled Actor");
    if (TitleType != ENodeTitleType::MenuTitle)
    {
        if (UEdGraphPin* ClassPin = GetClassPin())
        {
            if (ClassPin->LinkedTo.Num() > 0)
            {
                // Blueprint will be determined dynamically, so we don't have the name in this case
                NodeTitle = NSLOCTEXT("K2Node", "SpawnActor_Title_Unknown", "SpawnPooledActor");
            }
            else if (ClassPin->DefaultObject == nullptr)
            {
                NodeTitle = NSLOCTEXT("K2Node", "SpawnActor_Title_NONE", "SpawnPooledActor NONE");
            }
            else
            {
                if (CachedNodeTitle.IsOutOfDate(this))
                {
                    FText ClassName;
                    if (UClass* PickedClass = Cast<UClass>(ClassPin->DefaultObject))
                    {
                        ClassName = PickedClass->GetDisplayNameText();
                    }

                    FFormatNamedArguments Args;
                    Args.Add(TEXT("ClassName"), ClassName);

                    // FText::Format() is slow, so we cache this to save on performance
                    CachedNodeTitle.SetCachedText(FText::Format(NSLOCTEXT("K2Node", "SpawnActor_Title_Class", "SpawnPooledActor {ClassName}"), Args), this);
                }
                NodeTitle = CachedNodeTitle;
            }
        }
        else
        {
            NodeTitle = NSLOCTEXT("K2Node", "SpawnActor_Title_NONE", "SpawnPooledActor NONE");
        }
    }
    return NodeTitle;
}

void UK2Node_SpawnPooledActor::GetPinHoverText(const UEdGraphPin& Pin, FString& HoverTextOut) const
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

    if (UEdGraphPin* TransformPin = GetSpawnTransformPin())
    {
        K2Schema->ConstructBasicPinTooltip(*TransformPin, LOCTEXT("TransformPinDescription", "The transform to spawn the Actor with"), TransformPin->PinToolTip);
    }
    if (UEdGraphPin* RecyclePin = GetRecyclePin())
    {
        K2Schema->ConstructBasicPinTooltip(*RecyclePin, LOCTEXT("RecyclePinDescription", "If set, this will reclaim the oldest live actor if there are none free."), RecyclePin->PinToolTip);
    }
    if (UEdGraphPin* OwnerPin = GetOwnerPin())
    {
        K2Schema->ConstructBasicPinTooltip(*OwnerPin, LOCTEXT("OwnerPinDescription", "Can be left empty; primarily used for replication (bNetUseOwnerRelevancy and bOnlyRelevantToOwner), or visibility (PrimitiveComponent's bOwnerNoSee/bOnlyOwnerSee)"), OwnerPin->PinToolTip);
    }

    return Super::GetPinHoverText(Pin, HoverTextOut);
}

void UK2Node_SpawnPooledActor::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    Super::ExpandNode(CompilerContext, SourceGraph);

    static const FName BeginSpawningBlueprintFuncName = GET_FUNCTION_NAME_CHECKED(UToasterGameplayStatics, SpawnPooledActorDefer);
    static const FName ActorClassParamName(TEXT("ActorClass"));
    static const FName WorldContextParamName(TEXT("WorldContextObject"));
    static const FName TransformParamName(TEXT("Transform"));
    static const FName RecycleParamName(TEXT("bReclaimIfEmpty"));

    static const FName FinishSpawningFuncName = GET_FUNCTION_NAME_CHECKED(UToasterGameplayStatics, FinishSpawningPooledActor);
    static const FName PooledActorParamName(TEXT("PooledActor"));
    static const FName OwnerParamName(TEXT("Owner"));

    static const FName ObjectParamName(TEXT("Object"));
    static const FName ValueParamName(TEXT("Value"));
    static const FName PropertyNameParamName(TEXT("PropertyName"));

    UK2Node_SpawnPooledActor* SpawnNode = this;
    UEdGraphPin* SpawnNodeExec = SpawnNode->GetExecPin();
    UEdGraphPin* SpawnNodeTransform = SpawnNode->GetSpawnTransformPin();
    UEdGraphPin* SpawnWorldContextPin = SpawnNode->GetWorldContextPin();
    UEdGraphPin* SpawnClassPin = SpawnNode->GetClassPin();
    UEdGraphPin* SpawnNodeOwnerPin = SpawnNode->GetOwnerPin();
    UEdGraphPin* SpawnNodeRecyclePin = SpawnNode->GetRecyclePin();
    UEdGraphPin* SpawnNodeThen = SpawnNode->GetThenPin();
    UEdGraphPin* SpawnNodeResult = SpawnNode->GetResultPin();

    UClass* ClassToSpawn = GetClassToSpawn();

    UClass* SpawnClass = (SpawnClassPin != NULL) ? Cast<UClass>(SpawnClassPin->DefaultObject) : NULL;
    if (!SpawnClassPin || ((0 == SpawnClassPin->LinkedTo.Num()) && (NULL == SpawnClass)))
    {
        CompilerContext.MessageLog.Error(*LOCTEXT("SpawnActorNodeMissingClass_Error", "Spawn node @@ must have a @@ specified.").ToString(), SpawnNode, SpawnClassPin);
        SpawnNode->BreakAllNodeLinks();
        return;
    }

    UK2Node_CallFunction* CallBeginSpawnNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(SpawnNode, SourceGraph);
    CallBeginSpawnNode->FunctionReference.SetExternalMember(BeginSpawningBlueprintFuncName, UToasterGameplayStatics::StaticClass());
    CallBeginSpawnNode->AllocateDefaultPins();

    UEdGraphPin* CallBeginExec = CallBeginSpawnNode->GetExecPin();
    UEdGraphPin* CallBeginWorldContextPin = CallBeginSpawnNode->FindPinChecked(WorldContextParamName);
    UEdGraphPin* CallBeginActorClassPin = CallBeginSpawnNode->FindPinChecked(ActorClassParamName);
    UEdGraphPin* CallBeginRecyclePin = CallBeginSpawnNode->FindPinChecked(RecycleParamName);
    UEdGraphPin* CallBeginTransform = CallBeginSpawnNode->FindPinChecked(TransformParamName);
    UEdGraphPin* CallBeginResult = CallBeginSpawnNode->GetReturnValuePin();

    CompilerContext.MovePinLinksToIntermediate(*SpawnNodeExec, *CallBeginExec);

    if (SpawnClassPin->LinkedTo.Num() > 0)
    {
        CompilerContext.MovePinLinksToIntermediate(*SpawnClassPin, *CallBeginActorClassPin);
    }
    else
    {
        CallBeginActorClassPin->DefaultObject = SpawnClass;
    }

    if (SpawnWorldContextPin)
    {
        CompilerContext.MovePinLinksToIntermediate(*SpawnWorldContextPin, *CallBeginWorldContextPin);
    }

    CompilerContext.MovePinLinksToIntermediate(*SpawnNodeTransform, *CallBeginTransform);

    if (SpawnNodeRecyclePin->LinkedTo.Num() > 0)
    {
        CompilerContext.MovePinLinksToIntermediate(*SpawnNodeRecyclePin, *CallBeginRecyclePin);
    }
    else
    {
        CallBeginRecyclePin->DefaultValue = SpawnNodeRecyclePin->DefaultValue;
    }

    UK2Node_CallFunction* CallFinishSpawnNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(SpawnNode, SourceGraph);
    CallFinishSpawnNode->FunctionReference.SetExternalMember(FinishSpawningFuncName, UToasterGameplayStatics::StaticClass());
    CallFinishSpawnNode->AllocateDefaultPins();

    UEdGraphPin* CallFinishExec = CallFinishSpawnNode->GetExecPin();
    UEdGraphPin* CallFinishThen = CallFinishSpawnNode->GetThenPin();
    UEdGraphPin* CallFinishActor = CallFinishSpawnNode->FindPinChecked(PooledActorParamName);
    UEdGraphPin* CallFinishOwnerPin = CallFinishSpawnNode->FindPinChecked(FSpawnPooledActorHelper::OwnerPinName);

    CompilerContext.MovePinLinksToIntermediate(*SpawnNodeThen, *CallFinishThen);
    CompilerContext.MovePinLinksToIntermediate(*SpawnNodeOwnerPin, *CallFinishOwnerPin);

    CallBeginResult->MakeLinkTo(CallFinishActor);

    CallBeginResult->PinType = SpawnNodeResult->PinType; // Copy type so it uses the right actor subclass
    CompilerContext.MovePinLinksToIntermediate(*SpawnNodeResult, *CallBeginResult);

    UEdGraphPin* LastThen = FKismetCompilerUtilities::GenerateAssignmentNodes(CompilerContext, SourceGraph, CallBeginSpawnNode, SpawnNode, CallBeginResult, ClassToSpawn);

    LastThen->MakeLinkTo(CallFinishExec);

    SpawnNode->BreakAllNodeLinks();
}

FSlateIcon UK2Node_SpawnPooledActor::GetIconAndTint(FLinearColor& OutColor) const
{
    static FSlateIcon Icon("EditorStyle", "GraphEditor.SpawnActor_16x");
    return Icon;
}

bool UK2Node_SpawnPooledActor::IsCompatibleWithGraph(const UEdGraph* TargetGraph) const
{
    UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(TargetGraph);
    return Super::IsCompatibleWithGraph(TargetGraph) && (!Blueprint || (FBlueprintEditorUtils::FindUserConstructionScript(Blueprint) != TargetGraph && Blueprint->GeneratedClass->GetDefaultObject()->ImplementsGetWorld()));
}

void UK2Node_SpawnPooledActor::GetNodeAttributes(TArray<TKeyValuePair<FString, FString>>& OutNodeAttributes) const
{
    UClass* ClassToSpawn = GetClassToSpawn();
    const FString ClassToSpawnStr = ClassToSpawn ? ClassToSpawn->GetName() : TEXT("InvalidClass");
    OutNodeAttributes.Add(TKeyValuePair<FString, FString>(TEXT("Type"), TEXT("SpawnPooledActor")));
    OutNodeAttributes.Add(TKeyValuePair<FString, FString>(TEXT("Class"), GetClass()->GetName()));
    OutNodeAttributes.Add(TKeyValuePair<FString, FString>(TEXT("Name"), GetName()));
    OutNodeAttributes.Add(TKeyValuePair<FString, FString>(TEXT("ActorClass"), ClassToSpawnStr));
}

class FNodeHandlingFunctor* UK2Node_SpawnPooledActor::CreateNodeHandler(class FKismetCompilerContext& CompilerContext) const
{
    return new FNodeHandlingFunctor(CompilerContext);
}

UClass* UK2Node_SpawnPooledActor::GetClassPinBaseClass() const
{
    return APooledActor::StaticClass();
}

bool UK2Node_SpawnPooledActor::IsSpawnVarPin(UEdGraphPin* Pin) const
{
    UEdGraphPin* ParentPin = Pin->ParentPin;
    while (ParentPin)
    {
        if (ParentPin->PinName == FSpawnPooledActorHelper::SpawnTransformPinName)
        {
            return false;
        }
        ParentPin = ParentPin->ParentPin;
    }

    return(Super::IsSpawnVarPin(Pin) &&
        Pin->PinName != FSpawnPooledActorHelper::RecyclePinName &&
        Pin->PinName != FSpawnPooledActorHelper::SpawnTransformPinName &&
        Pin->PinName != FSpawnPooledActorHelper::OwnerPinName);
}

UEdGraphPin* UK2Node_SpawnPooledActor::GetSpawnTransformPin() const
{
    UEdGraphPin* Pin = FindPinChecked(FSpawnPooledActorHelper::SpawnTransformPinName);
    check(Pin->Direction == EGPD_Input);
    return Pin;
}

UEdGraphPin* UK2Node_SpawnPooledActor::GetOwnerPin() const
{
    UEdGraphPin* Pin = FindPin(FSpawnPooledActorHelper::OwnerPinName);
    check(Pin == nullptr || Pin->Direction == EGPD_Input);
    return Pin;
}

UEdGraphPin* UK2Node_SpawnPooledActor::GetRecyclePin() const
{
    UEdGraphPin* Pin = FindPin(FSpawnPooledActorHelper::RecyclePinName);
    check(Pin == nullptr || Pin->Direction == EGPD_Input);
    return Pin;
}

#undef LOCTEXT_NAMESPACE